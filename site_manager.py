"""
Site management utilities for Lala Panel
"""
import os
import shutil
import subprocess
import secrets
import string
import re
from pathlib import Path

class SiteManager:
    """Manages site creation, deletion, and configuration"""
    
    def __init__(self, config):
        self.config = config
        self._init_config_values()
    
    def _get_config_value(self, key):
        """Helper to get config value from dict or object"""
        return self.config.get(key) if hasattr(self.config, 'get') else getattr(self.config, key)
    
    def _init_config_values(self):
        """Initialize configuration values"""
        self.sites_dir = self._get_config_value('SITES_DIR')
        self.log_dir = self._get_config_value('LOG_DIR')
        self.nginx_available = self._get_config_value('NGINX_SITES_AVAILABLE')
        self.nginx_enabled = self._get_config_value('NGINX_SITES_ENABLED')
        self.php_fpm_socket_dir = self._get_config_value('PHP_FPM_SOCKET_DIR')
    
    def create_site_directories(self, domain):
        """Create directories for a new site"""
        site_path = os.path.join(self.sites_dir, domain)
        log_path = os.path.join(self.log_dir, domain)
        
        # Create site directories
        os.makedirs(os.path.join(site_path, 'htdocs'), exist_ok=True)
        os.makedirs(os.path.join(site_path, 'tmp'), exist_ok=True)
        
        # Create log directory
        os.makedirs(log_path, exist_ok=True)
        
        # Create default index.php
        index_file = os.path.join(site_path, 'htdocs', 'index.php')
        with open(index_file, 'w') as f:
            f.write(f"""<?php
/**
 * Default page for {domain}
 * Powered by Lala Panel
 */
?>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{domain}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }}
        .container {{
            text-align: center;
            background: white;
            padding: 3rem;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }}
        h1 {{ color: #333; margin-bottom: 0.5rem; }}
        p {{ color: #666; }}
        .info {{ 
            margin-top: 2rem; 
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9rem;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸš€ Site is Live!</h1>
        <p>Your site <strong>{domain}</strong> is now active</p>
        <div class="info">
            <strong>PHP Version:</strong> <?php echo PHP_VERSION; ?><br>
            <strong>Server:</strong> Nginx + PHP-FPM<br>
            <strong>Powered by:</strong> Lala Panel
        </div>
    </div>
</body>
</html>
""")
        
        # Set appropriate permissions
        os.chmod(site_path, 0o755)
        os.chmod(os.path.join(site_path, 'htdocs'), 0o755)
        
        return site_path
    
    def create_nginx_config(self, domain, php_version, ssl_enabled=False, php_settings=None):
        """Create Nginx configuration for a site"""
        site_path = os.path.join(self.sites_dir, domain)
        log_path = os.path.join(self.log_dir, domain)
        config_path = os.path.join(self.nginx_available, domain)
        
        # PHP-FPM socket path
        php_fpm_socket = f"{self.php_fpm_socket_dir}/php{php_version}-fpm.sock"
        
        # Default PHP settings
        if php_settings is None:
            php_settings = {
                'upload_max_filesize': '100M',
                'post_max_size': '100M',
                'memory_limit': '256M',
                'max_execution_time': '60',
                'max_input_time': '60'
            }
        
        # Build PHP value string
        php_value = f"upload_max_filesize={php_settings.get('upload_max_filesize', '100M')} \\n "
        php_value += f"post_max_size={php_settings.get('post_max_size', php_settings.get('upload_max_filesize', '100M'))} \\n "
        php_value += f"memory_limit={php_settings.get('memory_limit', '256M')} \\n "
        php_value += f"max_execution_time={php_settings.get('max_execution_time', '60')} \\n "
        php_value += f"max_input_time={php_settings.get('max_input_time', '60')}"
        
        # Build config
        config = f"""# Nginx configuration for {domain}
# Generated by Lala Panel

server {{
    listen 80;
    server_name {domain} www.{domain};
    
    root {site_path}/htdocs;
    index index.php index.html index.htm;
    
    access_log {log_path}/access.log;
    error_log {log_path}/error.log;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # PHP handling via PHP-FPM
    location ~ \\.php$ {{
        try_files $uri =404;
        fastcgi_pass unix:{php_fpm_socket};
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
        fastcgi_param PHP_VALUE "{php_value}";
    }}
    
    # Static files
    location ~* \\.(jpg|jpeg|gif|png|css|js|ico|xml|svg|woff|woff2|ttf|eot)$ {{
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}
    
    # Let's Encrypt ACME challenge
    location ^~ /.well-known/acme-challenge/ {{
        allow all;
        default_type "text/plain";
    }}
    
    # Deny access to other hidden files
    location ~ /\\. {{
        deny all;
    }}
    
    # Default location
    location / {{
        try_files $uri $uri/ /index.php?$args;
    }}
"""
        
        if ssl_enabled:
            config += f"""
    # SSL redirect
    return 301 https://$server_name$request_uri;
}}

server {{
    listen 443 ssl http2;
    server_name {domain} www.{domain};
    
    root {site_path}/htdocs;
    index index.php index.html index.htm;
    
    access_log {log_path}/access.log;
    error_log {log_path}/error.log;
    
    # SSL certificates
    ssl_certificate /etc/letsencrypt/live/{domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{domain}/privkey.pem;
    
    # SSL settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # PHP handling via PHP-FPM
    location ~ \\.php$ {{
        try_files $uri =404;
        fastcgi_pass unix:{php_fpm_socket};
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
        fastcgi_param PHP_VALUE "{php_value}";
        fastcgi_param HTTPS on;
    }}
    
    # Static files
    location ~* \\.(jpg|jpeg|gif|png|css|js|ico|xml|svg|woff|woff2|ttf|eot)$ {{
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}
    
    # Let's Encrypt ACME challenge
    location ^~ /.well-known/acme-challenge/ {{
        allow all;
        default_type "text/plain";
    }}
    
    # Deny access to other hidden files
    location ~ /\\. {{
        deny all;
    }}
    
    # Default location
    location / {{
        try_files $uri $uri/ /index.php?$args;
    }}
"""
        
        config += "}\n"
        
        # Write config file
        with open(config_path, 'w') as f:
            f.write(config)
        
        return config_path
    
    def enable_site(self, domain):
        """Enable a site by creating symlink"""
        available_path = os.path.join(self.nginx_available, domain)
        enabled_path = os.path.join(self.nginx_enabled, domain)
        
        # Create symlink
        if not os.path.exists(enabled_path):
            os.symlink(available_path, enabled_path)
        
        # Test nginx config
        result = subprocess.run(['/usr/sbin/nginx', '-t'], capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"Nginx config test failed: {result.stderr}")
        
        # Reload nginx
        subprocess.run(['/usr/bin/systemctl', 'reload', 'nginx'], check=True)
    
    def disable_site(self, domain):
        """Disable a site by removing symlink"""
        enabled_path = os.path.join(self.nginx_enabled, domain)
        
        if os.path.exists(enabled_path):
            os.unlink(enabled_path)
        
        # Reload nginx
        subprocess.run(['/usr/bin/systemctl', 'reload', 'nginx'], check=True)
    
    def delete_site_files(self, domain):
        """Delete all files for a site"""
        site_path = os.path.join(self.sites_dir, domain)
        log_path = os.path.join(self.log_dir, domain)
        config_path = os.path.join(self.nginx_available, domain)
        enabled_path = os.path.join(self.nginx_enabled, domain)
        
        # Remove enabled symlink if exists
        if os.path.exists(enabled_path):
            os.unlink(enabled_path)
        
        # Remove directories
        if os.path.exists(site_path):
            shutil.rmtree(site_path)
        
        if os.path.exists(log_path):
            shutil.rmtree(log_path)
        
        # Remove config
        if os.path.exists(config_path):
            os.remove(config_path)
    
    def request_ssl_certificate(self, domain, include_www=True):
        """Request SSL certificate from Let's Encrypt"""
        letsencrypt_email = self._get_config_value('LETSENCRYPT_EMAIL')
        
        # Build certbot command
        cmd = [
            '/usr/bin/certbot', 'certonly',
            '--non-interactive',
            '--agree-tos',
            '--email', letsencrypt_email,
            '--webroot',
            '-w', os.path.join(self.sites_dir, domain, 'htdocs'),
            '-d', domain
        ]
        
        # Add www subdomain if requested
        if include_www:
            cmd.extend(['-d', f'www.{domain}'])
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            raise Exception(f"SSL certificate request failed: {result.stderr}")
        
        return True
    
    def update_php_version(self, domain, new_php_version):
        """Update PHP version for a site"""
        # Get current SSL status
        enabled_path = os.path.join(self.nginx_enabled, domain)
        config_path = os.path.join(self.nginx_available, domain)
        
        ssl_enabled = False
        if os.path.exists(config_path):
            with open(config_path, 'r') as f:
                ssl_enabled = 'ssl' in f.read()
        
        # Recreate nginx config with new PHP version
        self.create_nginx_config(domain, new_php_version, ssl_enabled)
        
        # Reload nginx
        subprocess.run(['/usr/bin/systemctl', 'reload', 'nginx'], check=True)
    
    def create_default_server_config(self):
        """Create default server config to reject unknown domains"""
        config_path = os.path.join(self.nginx_available, '000-default')
        
        config = """# Default server configuration for Lala Panel
# This catches all requests to unknown domains and rejects them

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    
    # Return 444 (connection closed without response) for unknown domains
    return 444;
}

server {
    listen 443 ssl default_server;
    listen [::]:443 ssl default_server;
    server_name _;
    
    # Use a self-signed certificate for the default SSL server
    # This prevents SSL errors when accessing via IP
    ssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;
    ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;
    
    # Return 444 (connection closed without response) for unknown domains
    return 444;
}
"""
        
        # Write config file
        with open(config_path, 'w') as f:
            f.write(config)
        
        # Create symlink if it doesn't exist
        enabled_path = os.path.join(self.nginx_enabled, '000-default')
        if not os.path.exists(enabled_path):
            os.symlink(config_path, enabled_path)
        
        return config_path


class DatabaseManager:
    """Manages MariaDB databases"""
    
    def __init__(self, config):
        self.config = config
        self.host = config.get('MARIADB_HOST') if hasattr(config, 'get') else getattr(config, 'MARIADB_HOST')
        self.port = config.get('MARIADB_PORT') if hasattr(config, 'get') else getattr(config, 'MARIADB_PORT')
        self.root_password = config.get('MARIADB_ROOT_PASSWORD') if hasattr(config, 'get') else getattr(config, 'MARIADB_ROOT_PASSWORD')
    
    def _validate_identifier(self, identifier):
        """Validate database/user identifier to prevent SQL injection"""
        if not re.match(r'^[a-zA-Z0-9_]+$', identifier):
            raise ValueError(f"Invalid identifier: {identifier}")
        return identifier
    
    def generate_password(self, length=16):
        """Generate a random password"""
        alphabet = string.ascii_letters + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(length))
    
    def create_database(self, db_name, db_user, db_password):
        """Create a new MariaDB database and user"""
        import pymysql
        
        # Validate identifiers to prevent SQL injection
        db_name = self._validate_identifier(db_name)
        db_user = self._validate_identifier(db_user)
        
        try:
            # Connect as root
            connection = pymysql.connect(
                host=self.host,
                port=self.port,
                user='root',
                password=self.root_password
            )
            
            with connection.cursor() as cursor:
                # Create database (identifier already validated)
                cursor.execute(f"CREATE DATABASE IF NOT EXISTS `{db_name}`")
                
                # Create user with parameterized password
                cursor.execute(
                    f"CREATE USER IF NOT EXISTS '{db_user}'@'localhost' IDENTIFIED BY %s",
                    (db_password,)
                )
                
                # Grant privileges (identifier already validated)
                cursor.execute(
                    f"GRANT ALL PRIVILEGES ON `{db_name}`.* TO '{db_user}'@'localhost'"
                )
                
                cursor.execute("FLUSH PRIVILEGES")
            
            connection.close()
            return True
            
        except Exception as e:
            raise Exception(f"Database creation failed: {str(e)}")
    
    def delete_database(self, db_name, db_user):
        """Delete a MariaDB database and user"""
        import pymysql
        
        # Validate identifiers to prevent SQL injection
        db_name = self._validate_identifier(db_name)
        db_user = self._validate_identifier(db_user)
        
        try:
            connection = pymysql.connect(
                host=self.host,
                port=self.port,
                user='root',
                password=self.root_password
            )
            
            with connection.cursor() as cursor:
                # Drop database (identifier already validated)
                cursor.execute(f"DROP DATABASE IF EXISTS `{db_name}`")
                
                # Drop user (identifier already validated)
                cursor.execute(f"DROP USER IF EXISTS '{db_user}'@'localhost'")
                
                cursor.execute("FLUSH PRIVILEGES")
            
            connection.close()
            return True
            
        except Exception as e:
            raise Exception(f"Database deletion failed: {str(e)}")


class UserManager:
    """Manages SSH/FTP users"""
    
    def __init__(self, config):
        self.config = config
        self.sites_dir = config.get('SITES_DIR') if hasattr(config, 'get') else getattr(config, 'SITES_DIR')
    
    def _validate_username(self, username):
        """Validate username to prevent command injection"""
        if not re.match(r'^[a-z0-9_]+$', username):
            raise ValueError(f"Invalid username: {username}")
        if len(username) > 32:
            raise ValueError("Username too long (max 32 characters)")
        return username
    
    def generate_password(self, length=16):
        """Generate a random password"""
        alphabet = string.ascii_letters + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(length))
    
    def create_ftp_user(self, username, password, site_domain, access_type='ftp'):
        """Create a system user for FTP/SSH access"""
        # Validate username
        username = self._validate_username(username)
        
        # Check if user already exists
        result = subprocess.run(['/usr/bin/id', username], capture_output=True, text=True)
        if result.returncode == 0:
            raise Exception(f"User {username} already exists")
        
        # Site directory
        site_dir = os.path.join(self.sites_dir, site_domain)
        
        if access_type == 'ssh':
            # Create user with SSH access
            subprocess.run([
                '/usr/sbin/useradd',
                '-m',  # Create home directory
                '-d', site_dir,  # Set home to site directory
                '-s', '/bin/bash',  # Shell access
                username
            ], check=True)
        else:
            # Create user with FTP only (restricted shell)
            subprocess.run([
                '/usr/sbin/useradd',
                '-m',  # Create home directory
                '-d', site_dir,  # Set home to site directory
                '-s', '/usr/sbin/nologin',  # No shell access
                username
            ], check=True)
        
        # Set password
        proc = subprocess.Popen(
            ['/usr/sbin/chpasswd'],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        proc.communicate(input=f"{username}:{password}\n")
        
        if proc.returncode != 0:
            # Clean up user if password setting failed
            subprocess.run(['/usr/sbin/userdel', '-r', username], check=False)
            raise Exception("Failed to set password")
        
        # Set proper permissions on site directory
        subprocess.run(['/bin/chown', '-R', f'{username}:www-data', site_dir], check=True)
        subprocess.run(['/bin/chmod', '-R', '750', site_dir], check=True)
        
        return True
    
    def delete_ftp_user(self, username):
        """Delete a system user"""
        # Validate username
        username = self._validate_username(username)
        
        # Delete user and home directory
        try:
            subprocess.run(['/usr/sbin/userdel', '-r', username], check=True)
            return True
        except subprocess.CalledProcessError as e:
            # User might not exist
            return False
