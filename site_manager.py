"""
Site management utilities for Lala Panel
"""
import os
import shutil
import subprocess
import secrets
import string
from pathlib import Path

class SiteManager:
    """Manages site creation, deletion, and configuration"""
    
    def __init__(self, config):
        self.config = config
        self._init_config_values()
    
    def _get_config_value(self, key):
        """Helper to get config value from dict or object"""
        return self.config.get(key) if hasattr(self.config, 'get') else getattr(self.config, key)
    
    def _init_config_values(self):
        """Initialize configuration values"""
        self.sites_dir = self._get_config_value('SITES_DIR')
        self.log_dir = self._get_config_value('LOG_DIR')
        self.nginx_available = self._get_config_value('NGINX_SITES_AVAILABLE')
        self.nginx_enabled = self._get_config_value('NGINX_SITES_ENABLED')
        self.frankenphp_dir = self._get_config_value('FRANKENPHP_DIR')
    
    def create_site_directories(self, domain):
        """Create directories for a new site"""
        site_path = os.path.join(self.sites_dir, domain)
        log_path = os.path.join(self.log_dir, domain)
        
        # Create site directories
        os.makedirs(os.path.join(site_path, 'htdocs'), exist_ok=True)
        os.makedirs(os.path.join(site_path, 'tmp'), exist_ok=True)
        
        # Create log directory
        os.makedirs(log_path, exist_ok=True)
        
        # Create default index.php
        index_file = os.path.join(site_path, 'htdocs', 'index.php')
        with open(index_file, 'w') as f:
            f.write(f"""<?php
/**
 * Default page for {domain}
 * Powered by Lala Panel
 */
?>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{domain}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }}
        .container {{
            text-align: center;
            background: white;
            padding: 3rem;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }}
        h1 {{ color: #333; margin-bottom: 0.5rem; }}
        p {{ color: #666; }}
        .info {{ 
            margin-top: 2rem; 
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9rem;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸš€ Site is Live!</h1>
        <p>Your site <strong>{domain}</strong> is now active</p>
        <div class="info">
            <strong>PHP Version:</strong> <?php echo PHP_VERSION; ?><br>
            <strong>Server:</strong> Nginx + FrankenPHP<br>
            <strong>Powered by:</strong> Lala Panel
        </div>
    </div>
</body>
</html>
""")
        
        # Set appropriate permissions
        os.chmod(site_path, 0o755)
        os.chmod(os.path.join(site_path, 'htdocs'), 0o755)
        
        return site_path
    
    def create_nginx_config(self, domain, php_version, ssl_enabled=False):
        """Create Nginx configuration for a site"""
        site_path = os.path.join(self.sites_dir, domain)
        log_path = os.path.join(self.log_dir, domain)
        config_path = os.path.join(self.nginx_available, domain)
        
        # FrankenPHP socket path
        frankenphp_socket = f"{self.frankenphp_dir}/php{php_version}/frankenphp.sock"
        
        # Build config
        config = f"""# Nginx configuration for {domain}
# Generated by Lala Panel

server {{
    listen 80;
    server_name {domain} www.{domain};
    
    root {site_path}/htdocs;
    index index.php index.html index.htm;
    
    access_log {log_path}/access.log;
    error_log {log_path}/error.log;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # PHP handling via FrankenPHP
    location ~ \\.php$ {{
        try_files $uri =404;
        fastcgi_pass unix:{frankenphp_socket};
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
        fastcgi_param PHP_VALUE "upload_max_filesize=100M \\n post_max_size=100M";
    }}
    
    # Static files
    location ~* \\.(jpg|jpeg|gif|png|css|js|ico|xml|svg|woff|woff2|ttf|eot)$ {{
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}
    
    # Deny access to hidden files
    location ~ /\\. {{
        deny all;
    }}
    
    # Default location
    location / {{
        try_files $uri $uri/ /index.php?$args;
    }}
"""
        
        if ssl_enabled:
            config += f"""
    # SSL redirect
    return 301 https://$server_name$request_uri;
}}

server {{
    listen 443 ssl http2;
    server_name {domain} www.{domain};
    
    root {site_path}/htdocs;
    index index.php index.html index.htm;
    
    access_log {log_path}/access.log;
    error_log {log_path}/error.log;
    
    # SSL certificates
    ssl_certificate /etc/letsencrypt/live/{domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{domain}/privkey.pem;
    
    # SSL settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # PHP handling via FrankenPHP
    location ~ \\.php$ {{
        try_files $uri =404;
        fastcgi_pass unix:{frankenphp_socket};
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
        fastcgi_param PHP_VALUE "upload_max_filesize=100M \\n post_max_size=100M";
        fastcgi_param HTTPS on;
    }}
    
    # Static files
    location ~* \\.(jpg|jpeg|gif|png|css|js|ico|xml|svg|woff|woff2|ttf|eot)$ {{
        expires 30d;
        add_header Cache-Control "public, immutable";
    }}
    
    # Deny access to hidden files
    location ~ /\\. {{
        deny all;
    }}
    
    # Default location
    location / {{
        try_files $uri $uri/ /index.php?$args;
    }}
"""
        
        config += "}\n"
        
        # Write config file
        with open(config_path, 'w') as f:
            f.write(config)
        
        return config_path
    
    def enable_site(self, domain):
        """Enable a site by creating symlink"""
        available_path = os.path.join(self.nginx_available, domain)
        enabled_path = os.path.join(self.nginx_enabled, domain)
        
        # Create symlink
        if not os.path.exists(enabled_path):
            os.symlink(available_path, enabled_path)
        
        # Test nginx config
        result = subprocess.run(['nginx', '-t'], capture_output=True, text=True)
        if result.returncode != 0:
            raise Exception(f"Nginx config test failed: {result.stderr}")
        
        # Reload nginx
        subprocess.run(['systemctl', 'reload', 'nginx'], check=True)
    
    def disable_site(self, domain):
        """Disable a site by removing symlink"""
        enabled_path = os.path.join(self.nginx_enabled, domain)
        
        if os.path.exists(enabled_path):
            os.unlink(enabled_path)
        
        # Reload nginx
        subprocess.run(['systemctl', 'reload', 'nginx'], check=True)
    
    def delete_site_files(self, domain):
        """Delete all files for a site"""
        site_path = os.path.join(self.sites_dir, domain)
        log_path = os.path.join(self.log_dir, domain)
        config_path = os.path.join(self.nginx_available, domain)
        
        # Remove directories
        if os.path.exists(site_path):
            shutil.rmtree(site_path)
        
        if os.path.exists(log_path):
            shutil.rmtree(log_path)
        
        # Remove config
        if os.path.exists(config_path):
            os.remove(config_path)
    
    def request_ssl_certificate(self, domain):
        """Request SSL certificate from Let's Encrypt"""
        letsencrypt_email = self._get_config_value('LETSENCRYPT_EMAIL')
        result = subprocess.run([
            'certbot', 'certonly',
            '--non-interactive',
            '--agree-tos',
            '--email', letsencrypt_email,
            '--webroot',
            '-w', os.path.join(self.sites_dir, domain, 'htdocs'),
            '-d', domain,
            '-d', f'www.{domain}'
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            raise Exception(f"SSL certificate request failed: {result.stderr}")
        
        return True
    
    def update_php_version(self, domain, new_php_version):
        """Update PHP version for a site"""
        # Get current SSL status
        enabled_path = os.path.join(self.nginx_enabled, domain)
        config_path = os.path.join(self.nginx_available, domain)
        
        ssl_enabled = False
        if os.path.exists(config_path):
            with open(config_path, 'r') as f:
                ssl_enabled = 'ssl' in f.read()
        
        # Recreate nginx config with new PHP version
        self.create_nginx_config(domain, new_php_version, ssl_enabled)
        
        # Reload nginx
        subprocess.run(['systemctl', 'reload', 'nginx'], check=True)


class DatabaseManager:
    """Manages MariaDB databases"""
    
    def __init__(self, config):
        self.config = config
        self.host = config.get('MARIADB_HOST') if hasattr(config, 'get') else getattr(config, 'MARIADB_HOST')
        self.port = config.get('MARIADB_PORT') if hasattr(config, 'get') else getattr(config, 'MARIADB_PORT')
        self.root_password = config.get('MARIADB_ROOT_PASSWORD') if hasattr(config, 'get') else getattr(config, 'MARIADB_ROOT_PASSWORD')
    
    def _validate_identifier(self, identifier):
        """Validate database/user identifier to prevent SQL injection"""
        import re
        if not re.match(r'^[a-zA-Z0-9_]+$', identifier):
            raise ValueError(f"Invalid identifier: {identifier}")
        return identifier
    
    def generate_password(self, length=16):
        """Generate a random password"""
        alphabet = string.ascii_letters + string.digits
        return ''.join(secrets.choice(alphabet) for _ in range(length))
    
    def create_database(self, db_name, db_user, db_password):
        """Create a new MariaDB database and user"""
        import pymysql
        
        # Validate identifiers to prevent SQL injection
        db_name = self._validate_identifier(db_name)
        db_user = self._validate_identifier(db_user)
        
        try:
            # Connect as root
            connection = pymysql.connect(
                host=self.host,
                port=self.port,
                user='root',
                password=self.root_password
            )
            
            with connection.cursor() as cursor:
                # Create database (identifier already validated)
                cursor.execute(f"CREATE DATABASE IF NOT EXISTS `{db_name}`")
                
                # Create user with parameterized password
                cursor.execute(
                    f"CREATE USER IF NOT EXISTS '{db_user}'@'localhost' IDENTIFIED BY %s",
                    (db_password,)
                )
                
                # Grant privileges (identifier already validated)
                cursor.execute(
                    f"GRANT ALL PRIVILEGES ON `{db_name}`.* TO '{db_user}'@'localhost'"
                )
                
                cursor.execute("FLUSH PRIVILEGES")
            
            connection.close()
            return True
            
        except Exception as e:
            raise Exception(f"Database creation failed: {str(e)}")
    
    def delete_database(self, db_name, db_user):
        """Delete a MariaDB database and user"""
        import pymysql
        
        # Validate identifiers to prevent SQL injection
        db_name = self._validate_identifier(db_name)
        db_user = self._validate_identifier(db_user)
        
        try:
            connection = pymysql.connect(
                host=self.host,
                port=self.port,
                user='root',
                password=self.root_password
            )
            
            with connection.cursor() as cursor:
                # Drop database (identifier already validated)
                cursor.execute(f"DROP DATABASE IF EXISTS `{db_name}`")
                
                # Drop user (identifier already validated)
                cursor.execute(f"DROP USER IF EXISTS '{db_user}'@'localhost'")
                
                cursor.execute("FLUSH PRIVILEGES")
            
            connection.close()
            return True
            
        except Exception as e:
            raise Exception(f"Database deletion failed: {str(e)}")
